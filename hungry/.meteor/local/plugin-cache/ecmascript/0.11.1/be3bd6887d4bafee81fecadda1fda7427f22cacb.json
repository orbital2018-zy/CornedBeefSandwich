{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry\\packages\\aldeed:autoform\\autoform-inputs.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/aldeed:autoform/autoform-inputs.js","filename":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry\\packages\\aldeed:autoform\\autoform-inputs.js","passPerPreset":false,"envName":"development","cwd":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry","root":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry","generatorOpts":{"filename":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry\\packages\\aldeed:autoform\\autoform-inputs.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/autoform-inputs.js"}},"code":"/* global AutoForm, getInputValue:true, getAllFieldsInForm:true, getInputData:true, updateTrackedFieldValue:true, updateAllTrackedFieldValues:true, getFlatDocOfFieldValues:true */\ngetFlatDocOfFieldValues = function getFlatDocOfFieldValues(fields, ss) {\n  var doc = {};\n  fields.each(function () {\n    var fieldName,\n        val = AutoForm.getInputValue(this, ss);\n\n    if (val !== void 0) {\n      // Get the field/schema key name\n      fieldName = $(this).attr('data-schema-key');\n      doc[fieldName] = val;\n    }\n  });\n  return doc;\n};\n/*\n * package scope functions\n */\n\n/*\n * Gets the value that should be shown/selected in the input. Returns\n * a string, a boolean, or an array of strings. The value used,\n * in order of preference, is one of:\n * * The `value` attribute provided\n * * The value that is set in the `doc` provided on the containing autoForm\n * * The `defaultValue` from the schema\n */\n\n\ngetInputValue = function getInputValue(atts, value, mDoc, schemaDefaultValue, fieldDefaultValue, typeDefs) {\n  if (typeof value === 'undefined') {\n    // Get the value for this key in the current document\n    if (mDoc) {\n      var valueInfo = mDoc.getInfoForKey(atts.name);\n\n      if (valueInfo) {\n        value = valueInfo.value;\n      } else {\n        value = fieldDefaultValue;\n      }\n    } // Only if there is no current document, use the schema defaultValue\n    else {\n        // Use the field default value if provided\n        if (typeof fieldDefaultValue !== 'undefined') {\n          value = fieldDefaultValue;\n        } // Or use the defaultValue in the schema\n        else {\n            value = schemaDefaultValue;\n          }\n      }\n  } // Change null or undefined to an empty string\n\n\n  value = value === null || value === void 0 ? '' : value; // If the component expects the value to be an array, and it's not, make it one\n\n  if (typeDefs.valueIsArray && !_.isArray(value)) {\n    if (typeof value === 'string') {\n      value = value.split(',');\n    } else {\n      value = [value];\n    }\n  } // At this point we have a value or an array of values.\n  // Run through the components valueIn function if we have one.\n  // It should then be in whatever format the component expects.\n\n\n  if (typeof typeDefs.valueIn === 'function') {\n    value = typeDefs.valueIn(value, atts);\n  }\n\n  return value;\n};\n/*\n * Builds the data context that the input component will have.\n */\n\n\ngetInputData = function getInputData(defs, hash, value, label, formType) {\n  /*\n   * Get HTML attributes\n   */\n  // We don't want to alter the original hash, so we clone it and\n  // remove some stuff that should not be HTML attributes.\n  var inputAtts = _.omit(hash, 'type', 'value', 'noselect', 'options', 'template', 'defaultValue', 'data'); // Add required if required\n\n\n  if (typeof inputAtts.required === 'undefined' && !defs.optional) {\n    inputAtts.required = '';\n  } // Add data-schema-key to every type of element\n\n\n  inputAtts['data-schema-key'] = inputAtts.name; // Set placeholder to label from schema if requested.\n  // We check hash.placeholder instead of inputAtts.placeholder because\n  // we're setting inputAtts.placeholder, so it wouldn't be the same on\n  // subsequent reactive runs of this function.\n\n  if (hash.placeholder === 'schemaLabel') {\n    inputAtts.placeholder = label;\n  } // To enable reactively toggling boolean attributes\n  // in a simple way, we add the attributes to the HTML\n  // only if their value is `true`. That is, unlike in\n  // HTML, their mere presence does not matter.\n\n\n  _.each(['disabled', 'readonly', 'checked', 'required', 'autofocus'], function (booleanProp) {\n    if (!_.has(hash, booleanProp)) {\n      return;\n    } // For historical reasons, we treat the string \"true\" and an empty string as `true`, too.\n    // But an empty string value results in the cleanest rendered output for boolean props,\n    // so we standardize as that.\n\n\n    if (hash[booleanProp] === true || hash[booleanProp] === 'true' || hash[booleanProp] === '') {\n      inputAtts[booleanProp] = '';\n    } else {\n      // If the value is anything else, we don't render it\n      delete inputAtts[booleanProp];\n    }\n  });\n  /*\n   * Set up the context. This is the object that becomes `this` in the\n   * input type template.\n   */\n\n\n  var inputTypeContext = {\n    name: inputAtts.name,\n    schemaType: defs.type,\n    min: defs.min,\n    max: defs.max,\n    value: value,\n    atts: inputAtts,\n    selectOptions: AutoForm.Utility.getSelectOptions(defs, hash)\n  };\n  /*\n   * Merge data property from the field schema with the context.\n   * We do not want these turned into HTML attributes.\n   */\n\n  if (hash.data) _.extend(inputTypeContext, hash.data); // Before returning the context, we allow the registered form type to\n  // adjust it if necessary.\n\n  var ftd = Utility.getFormTypeDef(formType);\n\n  if (typeof ftd.adjustInputContext === 'function') {\n    inputTypeContext = ftd.adjustInputContext(inputTypeContext);\n  }\n\n  return inputTypeContext;\n};\n\nfunction markChanged(template, fieldName) {\n  // We always want to be sure to wait for DOM updates to\n  // finish before we indicate that values have changed.\n  // Using a value of 0 here did not work, but 100 seems to\n  // work in testing. We'll need to keep an eye on this.\n  // Not an ideal solution.\n  setTimeout(function () {\n    // Template or view may have disappeared while\n    // we waited to run this\n    if (template && template.view && template.view._domrange && !template.view.isDestroyed && template.formValues[fieldName]) {\n      template.formValues[fieldName].changed();\n      template.formValues[fieldName].requestInProgress = false;\n    }\n  }, 100);\n}\n\nupdateTrackedFieldValue = function updateTrackedFieldValue(template, fieldName) {\n  if (!template) return;\n  template.formValues = template.formValues || {};\n\n  if (!template.formValues[fieldName]) {\n    template.formValues[fieldName] = new Tracker.Dependency();\n  } // In case we call updateTrackedFieldValue from multiple places at once,\n  // call .changed() only once\n\n\n  if (template.formValues[fieldName].requestInProgress) {\n    return;\n  }\n\n  template.formValues[fieldName].requestInProgress = true;\n  markChanged(template, fieldName); // To properly handle array fields, we'll mark the ancestors as changed, too\n  // XXX Might be a more elegant way to handle this\n\n  var dotPos = fieldName.lastIndexOf('.');\n\n  while (dotPos !== -1) {\n    fieldName = fieldName.slice(0, dotPos);\n\n    if (!template.formValues[fieldName]) {\n      template.formValues[fieldName] = new Tracker.Dependency();\n    }\n\n    markChanged(template, fieldName);\n    dotPos = fieldName.lastIndexOf('.');\n  }\n};\n\nupdateAllTrackedFieldValues = function updateAllTrackedFieldValues(template) {\n  if (template && template.formValues) {\n    _.each(template.formValues, function (o, fieldName) {\n      updateTrackedFieldValue(template, fieldName);\n    });\n  }\n};\n\ngetAllFieldsInForm = function getAllFieldsInForm(template) {\n  // Get all elements with `data-schema-key` attribute, unless disabled\n  return template.$('[data-schema-key]').not('[disabled]'); // Exclude fields in sub-forms, since they will belong to a different AutoForm and schema.\n  // TODO need some selector/filter that actually works correctly for excluding subforms\n  // return template.$('[data-schema-key]').not(\"[disabled]\").not(template.$('form form [data-schema-key]'));\n};","map":{"version":3,"sources":["packages/aldeed:autoform/autoform-inputs.js"],"names":["getFlatDocOfFieldValues","fields","ss","doc","each","fieldName","val","AutoForm","getInputValue","$","attr","atts","value","mDoc","schemaDefaultValue","fieldDefaultValue","typeDefs","valueInfo","getInfoForKey","name","valueIsArray","_","isArray","split","valueIn","getInputData","defs","hash","label","formType","inputAtts","omit","required","optional","placeholder","booleanProp","has","inputTypeContext","schemaType","type","min","max","selectOptions","Utility","getSelectOptions","data","extend","ftd","getFormTypeDef","adjustInputContext","markChanged","template","setTimeout","view","_domrange","isDestroyed","formValues","changed","requestInProgress","updateTrackedFieldValue","Tracker","Dependency","dotPos","lastIndexOf","slice","updateAllTrackedFieldValues","o","getAllFieldsInForm","not"],"mappings":"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","sourcesContent":["/* global AutoForm, getInputValue:true, getAllFieldsInForm:true, getInputData:true, updateTrackedFieldValue:true, updateAllTrackedFieldValues:true, getFlatDocOfFieldValues:true */\n\ngetFlatDocOfFieldValues = function getFlatDocOfFieldValues(fields, ss) {\n  var doc = {};\n  fields.each(function () {\n    var fieldName, val = AutoForm.getInputValue(this, ss);\n    if (val !== void 0) {\n      // Get the field/schema key name\n      fieldName = $(this).attr('data-schema-key');\n      doc[fieldName] = val;\n    }\n  });\n  return doc;\n};\n\n/*\n * package scope functions\n */\n\n/*\n * Gets the value that should be shown/selected in the input. Returns\n * a string, a boolean, or an array of strings. The value used,\n * in order of preference, is one of:\n * * The `value` attribute provided\n * * The value that is set in the `doc` provided on the containing autoForm\n * * The `defaultValue` from the schema\n */\ngetInputValue = function getInputValue(atts, value, mDoc, schemaDefaultValue, fieldDefaultValue, typeDefs) {\n\n  if (typeof value === 'undefined') {\n    // Get the value for this key in the current document\n    if (mDoc) {\n      var valueInfo = mDoc.getInfoForKey(atts.name);\n      if (valueInfo) {\n        value = valueInfo.value;\n      } else {\n        value = fieldDefaultValue;\n      }\n    }\n\n    // Only if there is no current document, use the schema defaultValue\n    else {\n      // Use the field default value if provided\n      if (typeof fieldDefaultValue !== 'undefined') {\n        value = fieldDefaultValue;\n      }\n      // Or use the defaultValue in the schema\n      else {\n        value = schemaDefaultValue;\n      }\n    }\n  }\n\n  // Change null or undefined to an empty string\n  value = (value === null || value === void 0) ? '' : value;\n\n  // If the component expects the value to be an array, and it's not, make it one\n  if (typeDefs.valueIsArray && !_.isArray(value)) {\n    if (typeof value === 'string') {\n      value = value.split(',');\n    } else {\n      value = [value];\n    }\n  }\n\n  // At this point we have a value or an array of values.\n  // Run through the components valueIn function if we have one.\n  // It should then be in whatever format the component expects.\n  if (typeof typeDefs.valueIn === 'function') {\n    value = typeDefs.valueIn(value, atts);\n  }\n\n  return value;\n};\n\n/*\n * Builds the data context that the input component will have.\n */\ngetInputData = function getInputData(defs, hash, value, label, formType) {\n\n  /*\n   * Get HTML attributes\n   */\n\n  // We don't want to alter the original hash, so we clone it and\n  // remove some stuff that should not be HTML attributes.\n  var inputAtts = _.omit(hash,\n    'type',\n    'value',\n    'noselect',\n    'options',\n    'template',\n    'defaultValue',\n    'data');\n\n  // Add required if required\n  if (typeof inputAtts.required === 'undefined' && !defs.optional) {\n    inputAtts.required = '';\n  }\n\n   // Add data-schema-key to every type of element\n  inputAtts['data-schema-key'] = inputAtts.name;\n\n  // Set placeholder to label from schema if requested.\n  // We check hash.placeholder instead of inputAtts.placeholder because\n  // we're setting inputAtts.placeholder, so it wouldn't be the same on\n  // subsequent reactive runs of this function.\n  if (hash.placeholder === 'schemaLabel') {\n    inputAtts.placeholder = label;\n  }\n\n  // To enable reactively toggling boolean attributes\n  // in a simple way, we add the attributes to the HTML\n  // only if their value is `true`. That is, unlike in\n  // HTML, their mere presence does not matter.\n  _.each(['disabled', 'readonly', 'checked', 'required', 'autofocus'], function (booleanProp) {\n    if (!_.has(hash, booleanProp)) {\n      return;\n    }\n\n    // For historical reasons, we treat the string \"true\" and an empty string as `true`, too.\n    // But an empty string value results in the cleanest rendered output for boolean props,\n    // so we standardize as that.\n    if (hash[booleanProp] === true || hash[booleanProp] === 'true' || hash[booleanProp] === '') {\n      inputAtts[booleanProp] = '';\n    } else {\n      // If the value is anything else, we don't render it\n      delete inputAtts[booleanProp];\n    }\n  });\n\n  /*\n   * Set up the context. This is the object that becomes `this` in the\n   * input type template.\n   */\n\n  var inputTypeContext = {\n    name: inputAtts.name,\n    schemaType: defs.type,\n    min: defs.min,\n    max: defs.max,\n    value: value,\n    atts: inputAtts,\n    selectOptions: AutoForm.Utility.getSelectOptions(defs, hash)\n  };\n\n  /*\n   * Merge data property from the field schema with the context.\n   * We do not want these turned into HTML attributes.\n   */\n  if (hash.data) _.extend(inputTypeContext, hash.data);\n\n  // Before returning the context, we allow the registered form type to\n  // adjust it if necessary.\n  var ftd = Utility.getFormTypeDef(formType);\n  if (typeof ftd.adjustInputContext === 'function') {\n    inputTypeContext = ftd.adjustInputContext(inputTypeContext);\n  }\n\n  return inputTypeContext;\n};\n\nfunction markChanged(template, fieldName) {\n  // We always want to be sure to wait for DOM updates to\n  // finish before we indicate that values have changed.\n  // Using a value of 0 here did not work, but 100 seems to\n  // work in testing. We'll need to keep an eye on this.\n  // Not an ideal solution.\n  setTimeout(function () {\n    // Template or view may have disappeared while\n    // we waited to run this\n    if (template &&\n        template.view &&\n        template.view._domrange &&\n        !template.view.isDestroyed &&\n        template.formValues[fieldName]) {\n\n      template.formValues[fieldName].changed();\n      template.formValues[fieldName].requestInProgress = false;\n\n    }\n  }, 100);\n}\n\nupdateTrackedFieldValue = function updateTrackedFieldValue(template, fieldName) {\n  if (!template) return;\n\n  template.formValues = template.formValues || {};\n  if (!template.formValues[fieldName]) {\n    template.formValues[fieldName] = new Tracker.Dependency();\n  }\n  // In case we call updateTrackedFieldValue from multiple places at once,\n  // call .changed() only once\n  if (template.formValues[fieldName].requestInProgress) {\n    return;\n  }\n  template.formValues[fieldName].requestInProgress = true;\n\n  markChanged(template, fieldName);\n\n  // To properly handle array fields, we'll mark the ancestors as changed, too\n  // XXX Might be a more elegant way to handle this\n  var dotPos = fieldName.lastIndexOf('.');\n  while (dotPos !== -1) {\n    fieldName = fieldName.slice(0, dotPos);\n\n    if (!template.formValues[fieldName]) {\n      template.formValues[fieldName] = new Tracker.Dependency();\n    }\n\n    markChanged(template, fieldName);\n\n    dotPos = fieldName.lastIndexOf('.');\n  }\n};\n\nupdateAllTrackedFieldValues = function updateAllTrackedFieldValues(template) {\n  if (template && template.formValues) {\n    _.each(template.formValues, function (o, fieldName) {\n      updateTrackedFieldValue(template, fieldName);\n    });\n  }\n};\n\ngetAllFieldsInForm = function getAllFieldsInForm(template) {\n  // Get all elements with `data-schema-key` attribute, unless disabled\n  return template.$('[data-schema-key]').not('[disabled]');\n  // Exclude fields in sub-forms, since they will belong to a different AutoForm and schema.\n  // TODO need some selector/filter that actually works correctly for excluding subforms\n  // return template.$('[data-schema-key]').not(\"[disabled]\").not(template.$('form form [data-schema-key]'));\n};\n"]},"sourceType":"script","hash":"be3bd6887d4bafee81fecadda1fda7427f22cacb"}
