{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry\\packages\\aldeed:autoform\\autoform-events.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/aldeed:autoform/autoform-events.js","filename":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry\\packages\\aldeed:autoform\\autoform-events.js","passPerPreset":false,"envName":"development","cwd":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry","root":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry","generatorOpts":{"filename":"C:\\Users\\sandh\\Documents\\NUS\\Orbital\\GitHungry\\app\\orbital\\hungrymine\\hungry\\packages\\aldeed:autoform\\autoform-events.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/autoform-events.js"}},"code":"/* global AutoForm, Hooks, validateField, updateTrackedFieldValue, arrayTracker, updateAllTrackedFieldValues */\n// all form events handled here\nvar lastAutoSaveElement = null;\nvar lastKeyVals = {};\n\nfunction beginSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return; // Get user-defined hooks\n\n  var hooks = Hooks.getHooks(formId, 'beginSubmit');\n\n  if (hooks.length) {\n    _.each(hooks, function beginSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find('button[type=submit]') || template.find('input[type=submit]');\n\n    if (submitButton) {\n      submitButton.disabled = true;\n    }\n  }\n}\n\nfunction endSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return; // Try to avoid incorrect reporting of which input caused autosave\n\n  lastAutoSaveElement = null; // Get user-defined hooks\n\n  var hooks = Hooks.getHooks(formId, 'endSubmit');\n\n  if (hooks.length) {\n    _.each(hooks, function endSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find('button[type=submit]') || template.find('input[type=submit]');\n\n    if (submitButton) {\n      submitButton.disabled = false;\n    }\n  }\n}\n\nfunction adjustKeyForArrays(key) {\n  var gKey = AutoForm.Utility.makeKeyGeneric(key);\n\n  if (gKey.slice(-2) === '.$' || gKey.indexOf('.$.') !== -1) {\n    key = gKey.slice(0, gKey.indexOf('.$'));\n  }\n\n  return key;\n}\n/**\n * Returns `true` if the specified validation type should\n * be revalidated only when the form is already invalid.\n * @param {String} validationType The validation type string.\n */\n\n\nfunction onlyIfAlreadyInvalid(validationType) {\n  return validationType === 'submitThenKeyup' || validationType === 'submitThenBlur';\n}\n/**\n * Given an element, returns the schema key for it, using the\n * `data-schema-key` attribute on the element or on the closest\n * element that has one.\n *\n * @param   {Element}          element The DOM element\n * @returns {String|undefined} The schema key\n */\n\n\nfunction getKeyForElement(element) {\n  var key = element.getAttribute('data-schema-key');\n\n  if (!key) {\n    key = $(element).closest('[data-schema-key]').attr('data-schema-key');\n  }\n\n  return key;\n} // throttle autosave, at most autosave every 500ms\n\n\nvar throttleAutosave = _.throttle(function (event) {\n  lastAutoSaveElement = event.target;\n  $(event.currentTarget).submit();\n}, 500, {\n  leading: false\n});\n\nTemplate.autoForm.events({\n  'submit form': function autoFormSubmitHandler(event, template) {\n    var formDoc; // Gather necessary form info\n\n    var formId = this.id;\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var formType = form.type; // ss will be the schema for the `schema` attribute if present,\n    // else the schema for the collection\n\n    var ss = AutoForm.getFormSchema(formId);\n    var collection = AutoForm.getFormCollection(formId);\n    var ssIsOverride = !!(collection && form.schema);\n    var currentDoc = form.doc;\n    var docId = currentDoc ? currentDoc._id : null;\n    var isValid;\n    var validationOptions = {\n      validationContext: formId,\n      filter: form.filter,\n      autoConvert: form.autoConvert,\n      removeEmptyStrings: form.removeEmptyStrings,\n      trimStrings: form.trimStrings\n    }; // Get the form type definition\n\n    var ftd;\n\n    try {\n      ftd = Utility.getFormTypeDef(formType);\n    } catch (err) {\n      event.preventDefault();\n      throw err;\n    } // Gather hooks\n\n\n    var onSuccessHooks = Hooks.getHooks(formId, 'onSuccess');\n    var onErrorHooks = Hooks.getHooks(formId, 'onError');\n    var beforeHooks = Hooks.getHooks(formId, 'before', formType);\n    var afterHooks = Hooks.getHooks(formId, 'after', formType); // Prep context with which hooks are called\n\n    var hookContext = {\n      addStickyValidationError: function (key, type, value) {\n        AutoForm.addStickyValidationError(formId, key, type, value);\n      },\n      autoSaveChangedElement: lastAutoSaveElement,\n      collection: collection,\n      currentDoc: currentDoc,\n      docId: docId,\n      event: event,\n      formAttributes: form,\n      formId: formId,\n      formTypeDefinition: ftd,\n      removeStickyValidationError: function (key) {\n        AutoForm.removeStickyValidationError(formId, key);\n      },\n      resetForm: function () {\n        AutoForm.resetForm(formId, template);\n      },\n      ss: ss,\n      ssIsOverride: ssIsOverride,\n      template: template,\n      validationContext: AutoForm.getValidationContext(formId)\n    }; // Gather all form values\n\n    if (ftd.needsModifierAndDoc) {\n      formDoc = AutoForm.getFormValues(formId, template, ss);\n      hookContext.updateDoc = formDoc.updateDoc;\n      hookContext.insertDoc = formDoc.insertDoc;\n    } else if (ftd.usesModifier) {\n      formDoc = AutoForm.getFormValues(formId, template, ss, true);\n      hookContext.updateDoc = formDoc;\n    } else {\n      formDoc = AutoForm.getFormValues(formId, template, ss, false);\n      hookContext.insertDoc = formDoc;\n    } // It is pretty unlikely since we are submitting it, but if\n    // for some reason this form is not currently rendered, we exit.\n\n\n    if (!formDoc) {\n      event.preventDefault();\n      return;\n    }\n\n    function endSubmission() {\n      // Run endSubmit hooks (re-enabled submit button or form, etc.)\n      endSubmit(formId, template, hookContext);\n    }\n\n    function failedValidation() {\n      // add validationErrors array as a property\n      // of the Error object before we call\n      // onError hooks\n      var ec = ss.namedContext(formId);\n      var ik = ec.validationErrors(),\n          error;\n\n      if (ik) {\n        if (ik.length) {\n          error = new Error(ik[0].message || ec.keyErrorMessage(ik[0].name));\n        } else {\n          error = new Error('form failed validation');\n        }\n\n        error.validationErrors = ik;\n      } else {\n        error = new Error('form failed validation');\n      }\n\n      _.each(onErrorHooks, function onErrorEach(hook) {\n        hook.call(hookContext, 'pre-submit validation', error);\n      });\n\n      event.preventDefault();\n      event.stopPropagation();\n      endSubmission();\n    } // Prep function that calls before hooks.\n\n\n    function runBeforeHooks(doc, next) {\n      // We call the hooks recursively, in order added,\n      // passing the result of the first hook to the\n      // second hook, etc.\n      function runHook(i, doc) {\n        var hook = beforeHooks[i];\n\n        if (!hook) {\n          // We've run all hooks; continue submission\n          next(doc);\n          return;\n        } // Define a `result` function\n\n\n        var cb = function (d) {\n          // If the hook returns false, we cancel\n          if (d === false) {\n            endSubmission();\n          } else if (!_.isObject(d)) {\n            throw new Error(\"A 'before' hook must return an object\");\n          } else {\n            runHook(i + 1, d);\n          }\n        }; // Add the `result` function to the before hook context\n\n\n        var ctx = _.extend({\n          result: _.once(cb)\n        }, hookContext);\n\n        var result = hook.call(ctx, doc); // If the hook returns undefined, we wait for it\n        // to call this.result()\n\n        if (result !== void 0) {\n          ctx.result(result);\n        }\n      }\n\n      runHook(0, doc);\n    } // Prep function that calls after, onError, and onSuccess hooks.\n    // Also resets the form on success.\n\n\n    function resultCallback(error, result) {\n      if (error) {\n        if (onErrorHooks && onErrorHooks.length) {\n          _.each(onErrorHooks, function onErrorEach(hook) {\n            hook.call(hookContext, formType, error);\n          });\n        } else if ((!afterHooks || !afterHooks.length) && ss.namedContext(formId).isValid()) {\n          // if there are no onError or \"after\" hooks or validation errors, log the error\n          // because it must be some other error from the server\n          console.log(error);\n        }\n      } else {\n        // By default, we reset form after successful submit, but\n        // you can opt out. We should never reset after submit\n        // when autosaving.\n        if (form.resetOnSuccess !== false && form.autosave !== true) {\n          AutoForm.resetForm(formId, template);\n        } // Set docId in the context for insert forms, too\n\n\n        if (formType === 'insert') {\n          hookContext.docId = result;\n        }\n\n        _.each(onSuccessHooks, function onSuccessEach(hook) {\n          hook.call(hookContext, formType, result);\n        });\n      }\n\n      _.each(afterHooks, function afterHooksEach(hook) {\n        hook.call(hookContext, error, result);\n      });\n\n      endSubmission();\n    } // Run beginSubmit hooks (disable submit button or form, etc.)\n    // NOTE: This needs to stay after getFormValues in case a\n    // beginSubmit hook disables inputs. We don't get values for\n    // disabled inputs, but if they are just disabling during submission,\n    // then we actually do want the values.\n    //\n    // Also keep this before prevalidation so that sticky errors can be\n    // removed in this hook.\n\n\n    beginSubmit(formId, template, hookContext); // Ask form type definition whether we should prevalidate. By default we do.\n\n    var shouldPrevalidate = ftd.shouldPrevalidate ? ftd.shouldPrevalidate.call(hookContext) : true;\n\n    if (shouldPrevalidate) {\n      // This validation pass happens before any \"before\" hooks run. We\n      // validate against the form schema. Then before hooks can add any missing\n      // properties before we validate against the full collection schema.\n      try {\n        isValid = form.validation === 'none' || ftd.validateForm.call({\n          form: form,\n          formDoc: formDoc,\n          useCollectionSchema: false\n        });\n      } catch (e) {\n        // Catch exceptions in validation functions which will bubble up here, cause a form with\n        // onSubmit() to submit prematurely and prevent the error from being reported\n        // (due to a page refresh).\n        console.error('Validation error', e);\n        isValid = false;\n      } // If we failed pre-submit validation, we stop submission.\n\n\n      if (isValid === false) {\n        failedValidation();\n        return;\n      }\n    } // Call onSubmit from the form type definition\n\n\n    ftd.onSubmit.call(_.extend({\n      runBeforeHooks: runBeforeHooks,\n      result: resultCallback,\n      endSubmission: endSubmission,\n      failedValidation: failedValidation,\n      validationOptions: validationOptions,\n      hookContext: hookContext\n    }, hookContext));\n  },\n  'keyup [data-schema-key]': function autoFormKeyUpHandler(event) {\n    // Ignore enter/return, shift, ctrl, cmd, tab, arrows, etc.\n    // Most of these are just optimizations, but without ignoring Enter, errors can fail to show up\n    // because of conflicts between running onSubmit handlers and this around the same time.\n    if (_.contains([13, 9, 16, 20, 17, 91, 37, 38, 39, 40], event.keyCode)) return; // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n\n    var formId = AutoForm.getFormId(); // Get current form data context\n\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var validationType = form.validation;\n    var skipEmpty = !(event.keyCode === 8 || event.keyCode === 46); // if deleting or backspacing, don't skip empty\n\n    if (validationType === 'keyup' || validationType === 'submitThenKeyup') {\n      var key = getKeyForElement(event.currentTarget);\n      if (!key) return;\n      validateField(key, formId, skipEmpty, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n\n      var arrayKey = adjustKeyForArrays(key);\n\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n      } // If the form should be auto-saved whenever updated, we do that on field\n      // changes instead of validating the field\n\n\n      if (form.autosaveOnKeyup === true) {\n        throttleAutosave(event);\n      }\n    }\n  },\n  'blur [data-schema-key]': function autoFormBlurHandler(event) {\n    // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n    var formId = AutoForm.getFormId(); // Get current form data context\n\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' || validationType === 'blur' || validationType === 'submitThenKeyup' || validationType === 'submitThenBlur') {\n      var key = getKeyForElement(event.currentTarget);\n\n      if (!key) {\n        return;\n      }\n\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n\n      var arrayKey = adjustKeyForArrays(key);\n\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'change form': function autoFormChangeHandler(event, template) {\n    var key = getKeyForElement(event.target);\n\n    if (!key) {\n      return;\n    }\n\n    var formId = this.id; // Some plugins, like jquery.inputmask, can cause infinite\n    // loops by continually saying the field changed when it did not,\n    // especially in an autosave situation. This is an attempt to\n    // prevent that from happening.\n\n    var $target = $(event.target);\n    var keyVal = $target.val();\n\n    if (event.target.type === 'checkbox') {\n      // Special handling for checkboxes, which always have the same value\n      keyVal = keyVal + '_' + $target.prop('checked');\n    }\n\n    keyVal = key + '___' + keyVal;\n\n    if (formId in lastKeyVals && keyVal === lastKeyVals[formId]) {\n      return;\n    }\n\n    lastKeyVals[formId] = keyVal; // Mark field value as changed for reactive updates\n\n    updateTrackedFieldValue(template, key); // Get current form data context\n\n    var form = AutoForm.getCurrentDataForForm(formId); // If the form should be auto-saved whenever updated, we do that on field\n    // changes instead of validating the field\n\n    if (form.autosave === true || form.autosaveOnKeyup === true) {\n      lastAutoSaveElement = event.target;\n      $(event.currentTarget).submit();\n      return;\n    }\n\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' || validationType === 'blur' || validationType === 'submitThenKeyup' || validationType === 'submitThenBlur') {\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n\n      var arrayKey = adjustKeyForArrays(key);\n\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'reset form': function autoFormResetHandler(event, template) {\n    var formId = this.id;\n    AutoForm.formPreserve.clearDocument(formId); // Reset array counts\n\n    arrayTracker.resetForm(formId);\n    var vc = AutoForm.getValidationContext(formId);\n    if (vc) vc.reset();\n    event.preventDefault();\n\n    AutoForm._forceResetFormValues(formId); // Mark all fields as changed\n\n\n    updateAllTrackedFieldValues(template); // Focus the autofocus element\n\n    template.$('[autofocus]').focus();\n  },\n  'keydown .autoform-array-item input': function (event) {\n    // When enter is pressed in an array item field, default behavior\n    // seems to be to \"click\" the remove item button. This doesn't make\n    // sense so we stop it.\n    if (event.keyCode === 13) {\n      event.preventDefault();\n    }\n  },\n  'click .autoform-remove-item': function autoFormClickRemoveItem(event, template) {\n    var self = this; // This type of button must be used within an afEachArrayItem block, so we know the context\n\n    event.preventDefault();\n    var name = self.arrayFieldName;\n    var minCount = self.minCount; // optional, overrides schema\n\n    var maxCount = self.maxCount; // optional, overrides schema\n\n    var index = self.index;\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId); // remove the item we clicked\n\n    arrayTracker.removeFromFieldAtIndex(formId, name, index, ss, minCount, maxCount);\n  },\n  'click .autoform-add-item': function autoFormClickAddItem(event, template) {\n    event.preventDefault(); // We pull from data attributes because the button could be manually\n    // added anywhere, so we don't know the data context.\n\n    var btn = $(event.currentTarget);\n    var name = btn.attr('data-autoform-field');\n    var minCount = btn.attr('data-autoform-minCount'); // optional, overrides schema\n\n    var maxCount = btn.attr('data-autoform-maxCount'); // optional, overrides schema\n\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId);\n    arrayTracker.addOneToField(formId, name, ss, minCount, maxCount);\n  }\n});","map":{"version":3,"sources":["packages/aldeed:autoform/autoform-events.js"],"names":["lastAutoSaveElement","lastKeyVals","beginSubmit","formId","template","hookContext","Utility","checkTemplate","hooks","Hooks","getHooks","length","_","each","beginSubmitHooks","hook","call","submitButton","find","disabled","endSubmit","endSubmitHooks","adjustKeyForArrays","key","gKey","AutoForm","makeKeyGeneric","slice","indexOf","onlyIfAlreadyInvalid","validationType","getKeyForElement","element","getAttribute","$","closest","attr","throttleAutosave","throttle","event","target","currentTarget","submit","leading","Template","autoForm","events","autoFormSubmitHandler","formDoc","id","form","getCurrentDataForForm","formType","type","ss","getFormSchema","collection","getFormCollection","ssIsOverride","schema","currentDoc","doc","docId","_id","isValid","validationOptions","validationContext","filter","autoConvert","removeEmptyStrings","trimStrings","ftd","getFormTypeDef","err","preventDefault","onSuccessHooks","onErrorHooks","beforeHooks","afterHooks","addStickyValidationError","value","autoSaveChangedElement","formAttributes","formTypeDefinition","removeStickyValidationError","resetForm","getValidationContext","needsModifierAndDoc","getFormValues","updateDoc","insertDoc","usesModifier","endSubmission","failedValidation","ec","namedContext","ik","validationErrors","error","Error","message","keyErrorMessage","name","onErrorEach","stopPropagation","runBeforeHooks","next","runHook","i","cb","d","isObject","ctx","extend","result","once","resultCallback","console","log","resetOnSuccess","autosave","onSuccessEach","afterHooksEach","shouldPrevalidate","validation","validateForm","useCollectionSchema","e","onSubmit","autoFormKeyUpHandler","contains","keyCode","getFormId","skipEmpty","validateField","arrayKey","autosaveOnKeyup","autoFormBlurHandler","autoFormChangeHandler","$target","keyVal","val","prop","updateTrackedFieldValue","autoFormResetHandler","formPreserve","clearDocument","arrayTracker","vc","reset","_forceResetFormValues","updateAllTrackedFieldValues","focus","autoFormClickRemoveItem","self","arrayFieldName","minCount","maxCount","index","data","removeFromFieldAtIndex","autoFormClickAddItem","btn","addOneToField"],"mappings":"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","sourcesContent":["/* global AutoForm, Hooks, validateField, updateTrackedFieldValue, arrayTracker, updateAllTrackedFieldValues */\n\n// all form events handled here\nvar lastAutoSaveElement = null;\nvar lastKeyVals = {};\n\nfunction beginSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return;\n\n  // Get user-defined hooks\n  var hooks = Hooks.getHooks(formId, 'beginSubmit');\n  if (hooks.length) {\n    _.each(hooks, function beginSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find('button[type=submit]') || template.find('input[type=submit]');\n    if (submitButton) {\n      submitButton.disabled = true;\n    }\n  }\n}\n\nfunction endSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return;\n\n  // Try to avoid incorrect reporting of which input caused autosave\n  lastAutoSaveElement = null;\n  // Get user-defined hooks\n  var hooks = Hooks.getHooks(formId, 'endSubmit');\n  if (hooks.length) {\n    _.each(hooks, function endSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find('button[type=submit]') || template.find('input[type=submit]');\n    if (submitButton) {\n      submitButton.disabled = false;\n    }\n  }\n}\n\nfunction adjustKeyForArrays(key) {\n  var gKey = AutoForm.Utility.makeKeyGeneric(key);\n  if (gKey.slice(-2) === '.$' || gKey.indexOf('.$.') !== -1) {\n    key = gKey.slice(0, gKey.indexOf('.$'));\n  }\n  return key;\n}\n\n/**\n * Returns `true` if the specified validation type should\n * be revalidated only when the form is already invalid.\n * @param {String} validationType The validation type string.\n */\nfunction onlyIfAlreadyInvalid(validationType) {\n  return validationType === 'submitThenKeyup' ||\n    validationType === 'submitThenBlur';\n}\n\n/**\n * Given an element, returns the schema key for it, using the\n * `data-schema-key` attribute on the element or on the closest\n * element that has one.\n *\n * @param   {Element}          element The DOM element\n * @returns {String|undefined} The schema key\n */\nfunction getKeyForElement(element) {\n  var key = element.getAttribute('data-schema-key');\n  if (!key) {\n    key = $(element).closest('[data-schema-key]').attr('data-schema-key');\n  }\n  return key;\n}\n\n// throttle autosave, at most autosave every 500ms\nvar throttleAutosave = _.throttle(function(event) {\n  lastAutoSaveElement = event.target;\n  $(event.currentTarget).submit();\n}, 500, { leading: false });\n\nTemplate.autoForm.events({\n  'submit form': function autoFormSubmitHandler(event, template) {\n    var formDoc;\n    // Gather necessary form info\n    var formId = this.id;\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var formType = form.type;\n    // ss will be the schema for the `schema` attribute if present,\n    // else the schema for the collection\n    var ss = AutoForm.getFormSchema(formId);\n    var collection = AutoForm.getFormCollection(formId);\n    var ssIsOverride = !!(collection && form.schema);\n\n    var currentDoc = form.doc;\n    var docId = currentDoc ? currentDoc._id : null;\n    var isValid;\n\n    var validationOptions = {\n      validationContext: formId,\n      filter: form.filter,\n      autoConvert: form.autoConvert,\n      removeEmptyStrings: form.removeEmptyStrings,\n      trimStrings: form.trimStrings\n    };\n\n    // Get the form type definition\n    var ftd;\n    try {\n      ftd = Utility.getFormTypeDef(formType);\n    } catch (err) {\n      event.preventDefault();\n      throw err;\n    }\n\n    // Gather hooks\n    var onSuccessHooks = Hooks.getHooks(formId, 'onSuccess');\n    var onErrorHooks = Hooks.getHooks(formId, 'onError');\n    var beforeHooks = Hooks.getHooks(formId, 'before', formType);\n    var afterHooks = Hooks.getHooks(formId, 'after', formType);\n\n    // Prep context with which hooks are called\n    var hookContext = {\n      addStickyValidationError: function (key, type, value) {\n        AutoForm.addStickyValidationError(formId, key, type, value);\n      },\n      autoSaveChangedElement: lastAutoSaveElement,\n      collection: collection,\n      currentDoc: currentDoc,\n      docId: docId,\n      event: event,\n      formAttributes: form,\n      formId: formId,\n      formTypeDefinition: ftd,\n      removeStickyValidationError: function (key) {\n        AutoForm.removeStickyValidationError(formId, key);\n      },\n      resetForm: function () {\n        AutoForm.resetForm(formId, template);\n      },\n      ss: ss,\n      ssIsOverride: ssIsOverride,\n      template: template,\n      validationContext: AutoForm.getValidationContext(formId)\n    };\n\n    // Gather all form values\n    if (ftd.needsModifierAndDoc) {\n      formDoc = AutoForm.getFormValues(formId, template, ss);\n      hookContext.updateDoc = formDoc.updateDoc;\n      hookContext.insertDoc = formDoc.insertDoc;\n    } else if (ftd.usesModifier) {\n      formDoc = AutoForm.getFormValues(formId, template, ss, true);\n      hookContext.updateDoc = formDoc;\n    } else {\n      formDoc = AutoForm.getFormValues(formId, template, ss, false);\n      hookContext.insertDoc = formDoc;\n    }\n\n    // It is pretty unlikely since we are submitting it, but if\n    // for some reason this form is not currently rendered, we exit.\n    if (!formDoc) {\n      event.preventDefault();\n      return;\n    }\n\n    function endSubmission() {\n      // Run endSubmit hooks (re-enabled submit button or form, etc.)\n      endSubmit(formId, template, hookContext);\n    }\n\n    function failedValidation() {\n      // add validationErrors array as a property\n      // of the Error object before we call\n      // onError hooks\n      var ec = ss.namedContext(formId);\n      var ik = ec.validationErrors(), error;\n      if (ik) {\n        if (ik.length) {\n          error = new Error(ik[0].message || ec.keyErrorMessage(ik[0].name));\n        } else {\n          error = new Error('form failed validation');\n        }\n        error.validationErrors = ik;\n      } else {\n        error = new Error('form failed validation');\n      }\n      _.each(onErrorHooks, function onErrorEach(hook) {\n        hook.call(hookContext, 'pre-submit validation', error);\n      });\n      event.preventDefault();\n      event.stopPropagation();\n      endSubmission();\n    }\n\n    // Prep function that calls before hooks.\n    function runBeforeHooks(doc, next) {\n      // We call the hooks recursively, in order added,\n      // passing the result of the first hook to the\n      // second hook, etc.\n      function runHook(i, doc) {\n        var hook = beforeHooks[i];\n\n        if (!hook) {\n          // We've run all hooks; continue submission\n          next(doc);\n          return;\n        }\n\n        // Define a `result` function\n        var cb = function (d) {\n          // If the hook returns false, we cancel\n          if (d === false) {\n            endSubmission();\n          } else if (!_.isObject(d)) {\n            throw new Error(\"A 'before' hook must return an object\");\n          } else {\n            runHook(i + 1, d);\n          }\n        };\n\n        // Add the `result` function to the before hook context\n        var ctx = _.extend({\n          result: _.once(cb)\n        }, hookContext);\n\n        var result = hook.call(ctx, doc);\n\n        // If the hook returns undefined, we wait for it\n        // to call this.result()\n        if (result !== void 0) {\n          ctx.result(result);\n        }\n      }\n\n      runHook(0, doc);\n    }\n\n    // Prep function that calls after, onError, and onSuccess hooks.\n    // Also resets the form on success.\n    function resultCallback(error, result) {\n      if (error) {\n        if (onErrorHooks && onErrorHooks.length) {\n          _.each(onErrorHooks, function onErrorEach(hook) {\n            hook.call(hookContext, formType, error);\n          });\n        } else if ((!afterHooks || !afterHooks.length) && ss.namedContext(formId).isValid()) {\n          // if there are no onError or \"after\" hooks or validation errors, log the error\n          // because it must be some other error from the server\n          console.log(error);\n        }\n      } else {\n        // By default, we reset form after successful submit, but\n        // you can opt out. We should never reset after submit\n        // when autosaving.\n        if (form.resetOnSuccess !== false && form.autosave !== true) {\n          AutoForm.resetForm(formId, template);\n        }\n        // Set docId in the context for insert forms, too\n        if (formType === 'insert') {\n          hookContext.docId = result;\n        }\n        _.each(onSuccessHooks, function onSuccessEach(hook) {\n          hook.call(hookContext, formType, result);\n        });\n      }\n      _.each(afterHooks, function afterHooksEach(hook) {\n        hook.call(hookContext, error, result);\n      });\n      endSubmission();\n    }\n\n    // Run beginSubmit hooks (disable submit button or form, etc.)\n    // NOTE: This needs to stay after getFormValues in case a\n    // beginSubmit hook disables inputs. We don't get values for\n    // disabled inputs, but if they are just disabling during submission,\n    // then we actually do want the values.\n    //\n    // Also keep this before prevalidation so that sticky errors can be\n    // removed in this hook.\n    beginSubmit(formId, template, hookContext);\n\n    // Ask form type definition whether we should prevalidate. By default we do.\n    var shouldPrevalidate = ftd.shouldPrevalidate ? ftd.shouldPrevalidate.call(hookContext) : true;\n\n    if (shouldPrevalidate) {\n      // This validation pass happens before any \"before\" hooks run. We\n      // validate against the form schema. Then before hooks can add any missing\n      // properties before we validate against the full collection schema.\n      try {\n        isValid = (form.validation === 'none') ||\n          ftd.validateForm.call({\n            form: form,\n            formDoc: formDoc,\n            useCollectionSchema: false\n          });\n      } catch (e) {\n        // Catch exceptions in validation functions which will bubble up here, cause a form with\n        // onSubmit() to submit prematurely and prevent the error from being reported\n        // (due to a page refresh).\n        console.error('Validation error', e);\n        isValid = false;\n      }\n      // If we failed pre-submit validation, we stop submission.\n      if (isValid === false) {\n        failedValidation();\n        return;\n      }\n    }\n\n    // Call onSubmit from the form type definition\n    ftd.onSubmit.call(_.extend({\n      runBeforeHooks: runBeforeHooks,\n      result: resultCallback,\n      endSubmission: endSubmission,\n      failedValidation: failedValidation,\n      validationOptions: validationOptions,\n      hookContext: hookContext\n    }, hookContext));\n  },\n  'keyup [data-schema-key]': function autoFormKeyUpHandler(event) {\n    // Ignore enter/return, shift, ctrl, cmd, tab, arrows, etc.\n    // Most of these are just optimizations, but without ignoring Enter, errors can fail to show up\n    // because of conflicts between running onSubmit handlers and this around the same time.\n    if (_.contains([13, 9, 16, 20, 17, 91, 37, 38, 39, 40], event.keyCode)) return;\n\n    // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n    var formId = AutoForm.getFormId();\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n\n    var validationType = form.validation;\n    var skipEmpty = !(event.keyCode === 8 || event.keyCode === 46); // if deleting or backspacing, don't skip empty\n\n    if ((validationType === 'keyup' || validationType === 'submitThenKeyup')) {\n      var key = getKeyForElement(event.currentTarget);\n      if (!key) return;\n\n      validateField(key, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n      }\n\n      // If the form should be auto-saved whenever updated, we do that on field\n      // changes instead of validating the field\n      if (form.autosaveOnKeyup === true) {\n        throttleAutosave(event);\n      }\n    }\n  },\n  'blur [data-schema-key]': function autoFormBlurHandler(event) {\n    // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n    var formId = AutoForm.getFormId();\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' ||\n        validationType === 'blur' ||\n        validationType === 'submitThenKeyup' ||\n        validationType === 'submitThenBlur') {\n      var key = getKeyForElement(event.currentTarget);\n      if (!key) {return;}\n\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'change form': function autoFormChangeHandler(event, template) {\n    var key = getKeyForElement(event.target);\n    if (!key) {return;}\n\n    var formId = this.id;\n\n    // Some plugins, like jquery.inputmask, can cause infinite\n    // loops by continually saying the field changed when it did not,\n    // especially in an autosave situation. This is an attempt to\n    // prevent that from happening.\n    var $target = $(event.target);\n    var keyVal = $target.val();\n    if (event.target.type === 'checkbox') {\n      // Special handling for checkboxes, which always have the same value\n      keyVal = keyVal + '_' + $target.prop('checked');\n    }\n\n    keyVal = key + '___' + keyVal;\n\n    if (formId in lastKeyVals && keyVal === lastKeyVals[formId]) {\n      return;\n    }\n    lastKeyVals[formId] = keyVal;\n\n    // Mark field value as changed for reactive updates\n    updateTrackedFieldValue(template, key);\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n\n    // If the form should be auto-saved whenever updated, we do that on field\n    // changes instead of validating the field\n    if (form.autosave === true || form.autosaveOnKeyup === true) {\n      lastAutoSaveElement = event.target;\n      $(event.currentTarget).submit();\n      return;\n    }\n\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' ||\n        validationType === 'blur' ||\n        validationType === 'submitThenKeyup' ||\n        validationType === 'submitThenBlur') {\n\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'reset form': function autoFormResetHandler(event, template) {\n    var formId = this.id;\n\n    AutoForm.formPreserve.clearDocument(formId);\n\n    // Reset array counts\n    arrayTracker.resetForm(formId);\n\n    var vc = AutoForm.getValidationContext(formId);\n    if (vc) vc.reset();\n\n    event.preventDefault();\n    AutoForm._forceResetFormValues(formId);\n\n    // Mark all fields as changed\n    updateAllTrackedFieldValues(template);\n    // Focus the autofocus element\n    template.$('[autofocus]').focus();\n\n  },\n  'keydown .autoform-array-item input': function (event) {\n    // When enter is pressed in an array item field, default behavior\n    // seems to be to \"click\" the remove item button. This doesn't make\n    // sense so we stop it.\n    if (event.keyCode === 13) {\n      event.preventDefault();\n    }\n  },\n  'click .autoform-remove-item': function autoFormClickRemoveItem(event, template) {\n    var self = this; // This type of button must be used within an afEachArrayItem block, so we know the context\n\n    event.preventDefault();\n\n    var name = self.arrayFieldName;\n    var minCount = self.minCount; // optional, overrides schema\n    var maxCount = self.maxCount; // optional, overrides schema\n    var index = self.index;\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId);\n\n    // remove the item we clicked\n    arrayTracker.removeFromFieldAtIndex(formId, name, index, ss, minCount, maxCount);\n  },\n  'click .autoform-add-item': function autoFormClickAddItem(event, template) {\n    event.preventDefault();\n\n    // We pull from data attributes because the button could be manually\n    // added anywhere, so we don't know the data context.\n    var btn = $(event.currentTarget);\n    var name = btn.attr('data-autoform-field');\n    var minCount = btn.attr('data-autoform-minCount'); // optional, overrides schema\n    var maxCount = btn.attr('data-autoform-maxCount'); // optional, overrides schema\n\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId);\n\n    arrayTracker.addOneToField(formId, name, ss, minCount, maxCount);\n  }\n});\n"]},"sourceType":"script","hash":"2049dc44b92ec4196355b488f2b30c950e5e8784"}
