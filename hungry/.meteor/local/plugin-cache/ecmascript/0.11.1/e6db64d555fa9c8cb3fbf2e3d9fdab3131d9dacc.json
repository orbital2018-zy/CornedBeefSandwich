{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\zhenying\\Hungry\\CornedBeefSandwich\\hungry\\packages\\aldeed:autoform\\utility.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/aldeed:autoform/utility.js","filename":"C:\\Users\\zhenying\\Hungry\\CornedBeefSandwich\\hungry\\packages\\aldeed:autoform\\utility.js","passPerPreset":false,"envName":"development","cwd":"C:\\Users\\zhenying\\Hungry\\CornedBeefSandwich\\hungry","root":"C:\\Users\\zhenying\\Hungry\\CornedBeefSandwich\\hungry","generatorOpts":{"filename":"C:\\Users\\zhenying\\Hungry\\CornedBeefSandwich\\hungry\\packages\\aldeed:autoform\\utility.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/utility.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/builtin/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nlet MongoObject;\nmodule.watch(require(\"mongo-object\"), {\n  default(v) {\n    MongoObject = v;\n  }\n\n}, 0);\n\n/* global Utility:true, AutoForm, moment */\nUtility = {\n  componentTypeList: ['afArrayField', 'afEachArrayItem', 'afFieldInput', 'afFormGroup', 'afObjectField', 'afQuickField', 'afQuickFields', 'autoForm', 'quickForm'],\n\n  /**\n   * @method Utility.cleanNulls\n   * @private\n   * @param {Object} doc - Source object\n   * @returns {Object}\n   *\n   * Returns an object in which all properties with null, undefined, or empty\n   * string values have been removed, recursively.\n   */\n  cleanNulls: function cleanNulls(doc, isArray, keepEmptyStrings) {\n    var newDoc = isArray ? [] : {};\n\n    _.each(doc, function (val, key) {\n      if (!_.isArray(val) && isBasicObject(val)) {\n        val = cleanNulls(val, false, keepEmptyStrings); // recurse into plain objects\n\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (_.isArray(val)) {\n        val = cleanNulls(val, true, keepEmptyStrings); // recurse into non-typed arrays\n\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (!Utility.isNullUndefinedOrEmptyString(val)) {\n        newDoc[key] = val;\n      } else if (keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n        newDoc[key] = val;\n      }\n    });\n\n    return newDoc;\n  },\n\n  /**\n   * @method Utility.reportNulls\n   * @private\n   * @param {Object} flatDoc - An object with no properties that are also objects.\n   * @returns {Object} An object in which the keys represent the keys in the\n   * original object that were null, undefined, or empty strings, and the value\n   * of each key is \"\".\n   */\n  reportNulls: function reportNulls(flatDoc, keepEmptyStrings) {\n    var nulls = {}; // Loop through the flat doc\n\n    _.each(flatDoc, function (val, key) {\n      // If value is undefined, null, or an empty string, report this as null so it will be unset\n      if (val === null) {\n        nulls[key] = '';\n      } else if (val === void 0) {\n        nulls[key] = '';\n      } else if (!keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n        nulls[key] = '';\n      } // If value is an array in which all the values recursively are undefined, null, or an empty string, report this as null so it will be unset\n      else if (_.isArray(val) && Utility.cleanNulls(val, true, keepEmptyStrings).length === 0) {\n          nulls[key] = '';\n        }\n    });\n\n    return nulls;\n  },\n\n  /**\n   * @method Utility.docToModifier\n   * @private\n   * @param {Object} doc - An object to be converted into a MongoDB modifier\n   * @param {Object} [options] - Options\n   * @param {Boolean} [options.keepEmptyStrings] - Pass `true` to keep empty strings in the $set. Otherwise $unset them.\n   * @param {Boolean} [options.keepArrays] - Pass `true` to $set entire arrays. Otherwise the modifier will $set individual array items.\n   * @returns {Object} A MongoDB modifier.\n   *\n   * Converts an object into a modifier by flattening it, putting keys with\n   * null, undefined, and empty string values into `modifier.$unset`, and\n   * putting the rest of the keys into `modifier.$set`.\n   */\n  docToModifier: function docToModifier(doc, options) {\n    var modifier = {},\n        mDoc,\n        flatDoc,\n        nulls;\n    options = options || {}; // Flatten doc\n\n    mDoc = new MongoObject(doc);\n    flatDoc = mDoc.getFlatObject({\n      keepArrays: !!options.keepArrays\n    }); // Get a list of null, undefined, and empty string values so we can unset them instead\n\n    nulls = Utility.reportNulls(flatDoc, !!options.keepEmptyStrings);\n    flatDoc = Utility.cleanNulls(flatDoc, false, !!options.keepEmptyStrings);\n\n    if (!_.isEmpty(flatDoc)) {\n      modifier.$set = flatDoc;\n    }\n\n    if (!_.isEmpty(nulls)) {\n      modifier.$unset = nulls;\n    }\n\n    return modifier;\n  },\n\n  /**\n   * @method Utility.getSelectValues\n   * @private\n   * @param {Element} select - DOM Element from which to get current values\n   * @returns {string[]}\n   *\n   * Gets a string array of all the selected values in a given `select` DOM element.\n   */\n  getSelectValues: function getSelectValues(select) {\n    var result = [];\n    var options = select && select.options || [];\n    var opt;\n\n    for (var i = 0, ln = options.length; i < ln; i++) {\n      opt = options[i];\n\n      if (opt.selected) {\n        result.push(opt.value || opt.text);\n      }\n    }\n\n    return result;\n  },\n\n  /*\n   * Get select options\n   */\n  getSelectOptions: function getSelectOptions(defs, hash) {\n    var schemaType = defs.type;\n    var selectOptions = hash.options; // Handle options=\"allowed\"\n\n    if (selectOptions === 'allowed') {\n      selectOptions = _.map(defs.allowedValues, function (v) {\n        var label = v;\n\n        if (hash.capitalize && v.length > 0 && schemaType === String) {\n          label = v.charAt(0).toUpperCase() + v.slice(1).toLowerCase();\n        }\n\n        return {\n          label: label,\n          value: v\n        };\n      });\n    } // Hashtable\n    else if (_.isObject(selectOptions) && !_.isArray(selectOptions)) {\n        selectOptions = _.map(selectOptions, function (v, k) {\n          return {\n            label: v,\n            value: schemaType(k)\n          };\n        });\n      }\n\n    return selectOptions;\n  },\n\n  /**\n   * @method Utility.lookup\n   * @private\n   * @param {Any} obj\n   * @returns {Any}\n   *\n   * If `obj` is a string, returns the value of the property with that\n   * name on the `window` object. Otherwise returns `obj`.\n   */\n  lookup: function lookup(obj) {\n    var ref = window,\n        arr;\n\n    if (typeof obj === 'string') {\n      arr = obj.split('.');\n\n      while (arr.length && (ref = ref[arr.shift()]));\n\n      if (!ref) {\n        throw new Error(obj + ' is not in the window scope');\n      }\n\n      return ref;\n    }\n\n    return obj;\n  },\n\n  /**\n   * @method Utility.getFieldDefinition\n   * @private\n   * @param {SimpleSchema} ss\n   * @param {String} name\n   * @return {Object} Schema definitions object\n   *\n   * Returns the schema definitions object from a SimpleSchema instance, grabbing the first\n   * type definition out of potentially multiple.\n   */\n  getFieldDefinition(ss, name) {\n    const def = ss.getDefinition(name);\n    if (!def) return;\n    return (0, _objectSpread2.default)({}, def, def.type && def.type[0] || {});\n  },\n\n  /**\n   * @method Utility.objAffectsKey\n   * @private\n   * @param  {Object} obj\n   * @param  {String} key\n   * @return {Boolean}\n   * @todo should make this a static method in MongoObject\n   */\n  objAffectsKey: function objAffectsKey(obj, key) {\n    var mDoc = new MongoObject(obj);\n    return mDoc.affectsKey(key);\n  },\n\n  /**\n   * @method Utility.expandObj\n   * @private\n   * @param  {Object} doc\n   * @return {Object}\n   *\n   * Takes a flat object and returns an expanded version of it.\n   */\n  expandObj: function expandObj(doc) {\n    var newDoc = {},\n        subkeys,\n        subkey,\n        subkeylen,\n        nextPiece,\n        current;\n\n    _.each(doc, function (val, key) {\n      subkeys = key.split('.');\n      subkeylen = subkeys.length;\n      current = newDoc;\n\n      for (var i = 0; i < subkeylen; i++) {\n        subkey = subkeys[i];\n\n        if (typeof current[subkey] !== 'undefined' && !_.isObject(current[subkey])) {\n          break; // already set for some reason; leave it alone\n        }\n\n        if (i === subkeylen - 1) {\n          // last iteration; time to set the value\n          current[subkey] = val;\n        } else {\n          // see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n\n          if (isNaN(nextPiece) && !_.isObject(current[subkey])) {\n            current[subkey] = {};\n          } else if (!isNaN(nextPiece) && !_.isArray(current[subkey])) {\n            current[subkey] = [];\n          }\n        }\n\n        current = current[subkey];\n      }\n    });\n\n    return newDoc;\n  },\n\n  /**\n   * @method Utility.compactArrays\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference, compacting any arrays at any level recursively.\n   */\n  compactArrays: function compactArrays(obj) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          obj[key] = _.without(val, void 0, null);\n\n          _.each(obj[key], function (arrayItem) {\n            compactArrays(arrayItem);\n          });\n        } else if (!(val instanceof Date) && _.isObject(val)) {\n          // recurse into objects\n          compactArrays(val);\n        }\n      });\n    }\n  },\n\n  /**\n   * @method Utility.bubbleEmpty\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference.\n   */\n  bubbleEmpty: function bubbleEmpty(obj, keepEmptyStrings) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          _.each(val, function (arrayItem) {\n            bubbleEmpty(arrayItem);\n          });\n        } else if (isBasicObject(val)) {\n          var allEmpty = _.all(val, function (prop) {\n            return prop === void 0 || prop === null || !keepEmptyStrings && typeof prop === 'string' && prop.length === 0;\n          });\n\n          if (_.isEmpty(val) || allEmpty) {\n            obj[key] = null;\n          } else {\n            // recurse into objects\n            bubbleEmpty(val);\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * @method Utility.isNullUndefinedOrEmptyString\n   * @private\n   * @param  {Any} val\n   * @return {Boolean}\n   *\n   * Returns `true` if the value is null, undefined, or an empty string\n   */\n  isNullUndefinedOrEmptyString: function isNullUndefinedOrEmptyString(val) {\n    return val === void 0 || val === null || typeof val === 'string' && val.length === 0;\n  },\n\n  /**\n   * @method Utility.isValidDateString\n   * @private\n   * @param  {String}  dateString\n   * @return {Boolean}\n   *\n   * Returns `true` if dateString is a \"valid date string\"\n   */\n  isValidDateString: function isValidDateString(dateString) {\n    var m = moment(dateString, 'YYYY-MM-DD', true);\n    return m && m.isValid();\n  },\n\n  /**\n   * @method Utility.isValidTimeString\n   * @private\n   * @param  {String}  timeString\n   * @return {Boolean}\n   *\n   * Returns `true` if timeString is a \"valid time string\"\n   */\n  isValidTimeString: function isValidTimeString(timeString) {\n    if (typeof timeString !== 'string') {\n      return false;\n    } // this reg ex actually allows a few invalid hours/minutes/seconds, but\n    // we can catch that when parsing\n\n\n    var regEx = /^[0-2][0-9]:[0-5][0-9](:[0-5][0-9](\\.[0-9]{1,3})?)?$/;\n    return regEx.test(timeString);\n  },\n\n  /**\n   * @method  Utility.isValidNormalizedForcedUtcGlobalDateAndTimeString\n   * @private\n   * @param  {String} dateString\n   * @return {Boolean}\n   *\n   * Returns true if dateString is a \"valid normalized forced-UTC global date and time string\"\n   */\n  isValidNormalizedForcedUtcGlobalDateAndTimeString: function isValidNormalizedForcedUtcGlobalDateAndTimeString(dateString) {\n    if (typeof dateString !== 'string') {\n      return false;\n    }\n\n    var datePart = dateString.substring(0, 10);\n    var tPart = dateString.substring(10, 11);\n    var timePart = dateString.substring(11, dateString.length - 1);\n    var zPart = dateString.substring(dateString.length - 1);\n    return Utility.isValidDateString(datePart) && tPart === 'T' && Utility.isValidTimeString(timePart) && zPart === 'Z';\n  },\n\n  /**\n   * @method  Utility.isValidNormalizedLocalDateAndTimeString\n   * @private\n   * @param  {String} dtString\n   * @return {Boolean}\n   *\n   * Returns true if dtString is a \"valid normalized local date and time string\"\n   */\n  isValidNormalizedLocalDateAndTimeString: function isValidNormalizedLocalDateAndTimeString(dtString) {\n    if (typeof dtString !== 'string') {\n      return false;\n    }\n\n    var datePart = dtString.substring(0, 10);\n    var tPart = dtString.substring(10, 11);\n    var timePart = dtString.substring(11, dtString.length);\n    return Utility.isValidDateString(datePart) && tPart === 'T' && Utility.isValidTimeString(timePart);\n  },\n\n  /**\n   * @method Utility.getComponentContext\n   * @private\n   * @param  {Object} context A context (`this`) object\n   * @param {String} name The name of the helper or component we're calling from.\n   * @return {Object} Normalized context object\n   *\n   * Returns an object with `atts` and `defs` properties, normalized from whatever object is passed in.\n   * This helps deal with the fact that we have to pass the ancestor autoform's context to different\n   * helpers and components in different ways, but in all cases we want to get access to it and throw\n   * an error if we can't find an autoform context.\n   */\n  getComponentContext: function autoFormGetComponentContext(context, name) {\n    var atts,\n        defs = {},\n        formComponentAttributes,\n        fieldAttributes,\n        fieldAttributesForComponentType,\n        ss;\n    atts = _.clone(context || {});\n    ss = AutoForm.getFormSchema();\n    defs = Utility.getFieldDefinition(ss, atts.name);\n    if (!defs) return; // Look up the tree if we're in a helper, checking to see if any ancestor components\n    // had a <componentType>-attribute specified.\n\n    formComponentAttributes = AutoForm.findAttributesWithPrefix(name + '-'); // Get any field-specific attributes defined in the schema.\n    // They can be in autoform.attrName or autoform.componentType.attrName, with\n    // the latter overriding the former.\n\n    fieldAttributes = _.clone(defs.autoform) || {};\n    fieldAttributesForComponentType = fieldAttributes[name] || {};\n    fieldAttributes = _.omit(fieldAttributes, Utility.componentTypeList);\n    fieldAttributes = _.extend({}, fieldAttributes, fieldAttributesForComponentType); // \"autoform\" option in the schema provides default atts\n\n    atts = _.extend({}, formComponentAttributes, fieldAttributes, atts); // eval any attribute that is provided as a function\n\n    var evaluatedAtts = {};\n\n    _.each(atts, function (v, k) {\n      if (typeof v === 'function') {\n        evaluatedAtts[k] = v.call({\n          name: atts.name\n        });\n      } else {\n        evaluatedAtts[k] = v;\n      }\n    });\n\n    return {\n      atts: evaluatedAtts,\n      defs: defs\n    };\n  },\n\n  /**\n   * @method Utility.stringToArray\n   * @private\n   * @param {String|Array} s A variable that might be a string or an array.\n   * @param {String} errorMessage Error message to use if it's not a string or an array.\n   * @return {Array} The array, building it from a comma-delimited string if necessary.\n   */\n  stringToArray: function stringToArray(s, errorMessage) {\n    if (typeof s === 'string') {\n      return s.replace(/ /g, '').split(',');\n    } else if (!_.isArray(s)) {\n      throw new Error(errorMessage);\n    } else {\n      return s;\n    }\n  },\n\n  /**\n   * @method Utility.addClass\n   * @private\n   * @param {Object} atts An object that might have a \"class\" property\n   * @param {String} klass The class string to add\n   * @return {Object} The object with klass added to the \"class\" property, creating the property if necessary\n   */\n  addClass: function addClass(atts, klass) {\n    if (typeof atts['class'] === 'string') {\n      atts['class'] += ' ' + klass;\n    } else {\n      atts['class'] = klass;\n    }\n\n    return atts;\n  },\n\n  /**\n   * @method Utility.getFormTypeDef\n   * @private\n   * @param {String} formType The form type\n   * @return {Object} The definition. Throws an error if type hasn't been defined.\n   */\n  getFormTypeDef: function getFormTypeDef(formType) {\n    var ftd = AutoForm._formTypeDefinitions[formType];\n\n    if (!ftd) {\n      throw new Error('AutoForm: Form type \"' + formType + '\" has not been defined');\n    }\n\n    return ftd;\n  },\n  checkTemplate: function checkTemplate(template) {\n    return !!(template && template.view && template.view._domrange && !template.view.isDestroyed);\n  },\n\n  // This is copied from mongo-object to avoid a direct dep on that package\n  makeKeyGeneric(key) {\n    if (typeof key !== 'string') return null;\n    return key.replace(/\\.[0-9]+(?=\\.|$)/g, '.$');\n  }\n\n}; // getPrototypeOf polyfill\n\nif (typeof Object.getPrototypeOf !== 'function') {\n  if (typeof ''.__proto__ === 'object') {\n    Object.getPrototypeOf = function (object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function (object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n *\n * @param {any} obj\n * @returns {Boolean}\n */\n\n\nvar isBasicObject = function (obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};","map":{"version":3,"sources":["packages/aldeed:autoform/utility.js"],"names":["MongoObject","module","watch","require","default","v","Utility","componentTypeList","cleanNulls","doc","isArray","keepEmptyStrings","newDoc","_","each","val","key","isBasicObject","isEmpty","isNullUndefinedOrEmptyString","length","reportNulls","flatDoc","nulls","docToModifier","options","modifier","mDoc","getFlatObject","keepArrays","$set","$unset","getSelectValues","select","result","opt","i","ln","selected","push","value","text","getSelectOptions","defs","hash","schemaType","type","selectOptions","map","allowedValues","label","capitalize","String","charAt","toUpperCase","slice","toLowerCase","isObject","k","lookup","obj","ref","window","arr","split","shift","Error","getFieldDefinition","ss","name","def","getDefinition","objAffectsKey","affectsKey","expandObj","subkeys","subkey","subkeylen","nextPiece","current","parseInt","isNaN","compactArrays","without","arrayItem","Date","bubbleEmpty","allEmpty","all","prop","isValidDateString","dateString","m","moment","isValid","isValidTimeString","timeString","regEx","test","isValidNormalizedForcedUtcGlobalDateAndTimeString","datePart","substring","tPart","timePart","zPart","isValidNormalizedLocalDateAndTimeString","dtString","getComponentContext","autoFormGetComponentContext","context","atts","formComponentAttributes","fieldAttributes","fieldAttributesForComponentType","clone","AutoForm","getFormSchema","findAttributesWithPrefix","autoform","omit","extend","evaluatedAtts","call","stringToArray","s","errorMessage","replace","addClass","klass","getFormTypeDef","formType","ftd","_formTypeDefinitions","checkTemplate","template","view","_domrange","isDestroyed","makeKeyGeneric","Object","getPrototypeOf","__proto__","object","constructor","prototype"],"mappings":"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","sourcesContent":["import MongoObject from 'mongo-object';\n\n/* global Utility:true, AutoForm, moment */\n\nUtility = {\n  componentTypeList: ['afArrayField', 'afEachArrayItem', 'afFieldInput', 'afFormGroup', 'afObjectField', 'afQuickField', 'afQuickFields', 'autoForm', 'quickForm'],\n  /**\n   * @method Utility.cleanNulls\n   * @private\n   * @param {Object} doc - Source object\n   * @returns {Object}\n   *\n   * Returns an object in which all properties with null, undefined, or empty\n   * string values have been removed, recursively.\n   */\n  cleanNulls: function cleanNulls(doc, isArray, keepEmptyStrings) {\n    var newDoc = isArray ? [] : {};\n    _.each(doc, function(val, key) {\n      if (!_.isArray(val) && isBasicObject(val)) {\n        val = cleanNulls(val, false, keepEmptyStrings); // recurse into plain objects\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (_.isArray(val)) {\n        val = cleanNulls(val, true, keepEmptyStrings); // recurse into non-typed arrays\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (!Utility.isNullUndefinedOrEmptyString(val)) {\n        newDoc[key] = val;\n      } else if (keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n        newDoc[key] = val;\n      }\n    });\n    return newDoc;\n  },\n  /**\n   * @method Utility.reportNulls\n   * @private\n   * @param {Object} flatDoc - An object with no properties that are also objects.\n   * @returns {Object} An object in which the keys represent the keys in the\n   * original object that were null, undefined, or empty strings, and the value\n   * of each key is \"\".\n   */\n  reportNulls: function reportNulls(flatDoc, keepEmptyStrings) {\n    var nulls = {};\n    // Loop through the flat doc\n    _.each(flatDoc, function(val, key) {\n      // If value is undefined, null, or an empty string, report this as null so it will be unset\n      if (val === null) {\n        nulls[key] = '';\n      } else if (val === void 0) {\n        nulls[key] = '';\n      } else if (!keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n        nulls[key] = '';\n      }\n      // If value is an array in which all the values recursively are undefined, null, or an empty string, report this as null so it will be unset\n      else if (_.isArray(val) && Utility.cleanNulls(val, true, keepEmptyStrings).length === 0) {\n        nulls[key] = '';\n      }\n    });\n    return nulls;\n  },\n  /**\n   * @method Utility.docToModifier\n   * @private\n   * @param {Object} doc - An object to be converted into a MongoDB modifier\n   * @param {Object} [options] - Options\n   * @param {Boolean} [options.keepEmptyStrings] - Pass `true` to keep empty strings in the $set. Otherwise $unset them.\n   * @param {Boolean} [options.keepArrays] - Pass `true` to $set entire arrays. Otherwise the modifier will $set individual array items.\n   * @returns {Object} A MongoDB modifier.\n   *\n   * Converts an object into a modifier by flattening it, putting keys with\n   * null, undefined, and empty string values into `modifier.$unset`, and\n   * putting the rest of the keys into `modifier.$set`.\n   */\n  docToModifier: function docToModifier(doc, options) {\n    var modifier = {}, mDoc, flatDoc, nulls;\n    options = options || {};\n\n    // Flatten doc\n    mDoc = new MongoObject(doc);\n    flatDoc = mDoc.getFlatObject({ keepArrays: !!options.keepArrays });\n    // Get a list of null, undefined, and empty string values so we can unset them instead\n    nulls = Utility.reportNulls(flatDoc, !!options.keepEmptyStrings);\n    flatDoc = Utility.cleanNulls(flatDoc, false, !!options.keepEmptyStrings);\n\n    if (!_.isEmpty(flatDoc)) {\n      modifier.$set = flatDoc;\n    }\n    if (!_.isEmpty(nulls)) {\n      modifier.$unset = nulls;\n    }\n    return modifier;\n  },\n  /**\n   * @method Utility.getSelectValues\n   * @private\n   * @param {Element} select - DOM Element from which to get current values\n   * @returns {string[]}\n   *\n   * Gets a string array of all the selected values in a given `select` DOM element.\n   */\n  getSelectValues: function getSelectValues(select) {\n    var result = [];\n    var options = select && select.options || [];\n    var opt;\n\n    for (var i = 0, ln = options.length; i < ln; i++) {\n      opt = options[i];\n\n      if (opt.selected) {\n        result.push(opt.value || opt.text);\n      }\n    }\n    return result;\n  },\n  /*\n   * Get select options\n   */\n  getSelectOptions: function getSelectOptions(defs, hash) {\n    var schemaType = defs.type;\n    var selectOptions = hash.options;\n\n    // Handle options=\"allowed\"\n    if (selectOptions === 'allowed') {\n      selectOptions = _.map(defs.allowedValues, function(v) {\n        var label = v;\n        if (hash.capitalize && v.length > 0 && schemaType === String) {\n          label = v.charAt(0).toUpperCase() + v.slice(1).toLowerCase();\n        }\n\n        return { label: label, value: v };\n      });\n    }\n\n    // Hashtable\n    else if (_.isObject(selectOptions) && !_.isArray(selectOptions)) {\n      selectOptions = _.map(selectOptions, function(v, k) {\n        return { label: v, value: schemaType(k) };\n      });\n    }\n\n    return selectOptions;\n  },\n  /**\n   * @method Utility.lookup\n   * @private\n   * @param {Any} obj\n   * @returns {Any}\n   *\n   * If `obj` is a string, returns the value of the property with that\n   * name on the `window` object. Otherwise returns `obj`.\n   */\n  lookup: function lookup(obj) {\n    var ref = window, arr;\n    if (typeof obj === 'string') {\n      arr = obj.split('.');\n      while (arr.length && (ref = ref[arr.shift()]));\n      if (!ref) {\n        throw new Error(obj + ' is not in the window scope');\n      }\n      return ref;\n    }\n    return obj;\n  },\n  /**\n   * @method Utility.getFieldDefinition\n   * @private\n   * @param {SimpleSchema} ss\n   * @param {String} name\n   * @return {Object} Schema definitions object\n   *\n   * Returns the schema definitions object from a SimpleSchema instance, grabbing the first\n   * type definition out of potentially multiple.\n   */\n  getFieldDefinition(ss, name) {\n    const def = ss.getDefinition(name);\n    if (!def) return;\n\n    return {\n      ...def,\n      ...(def.type && def.type[0]) || {},\n    };\n  },\n  /**\n   * @method Utility.objAffectsKey\n   * @private\n   * @param  {Object} obj\n   * @param  {String} key\n   * @return {Boolean}\n   * @todo should make this a static method in MongoObject\n   */\n  objAffectsKey: function objAffectsKey(obj, key) {\n    var mDoc = new MongoObject(obj);\n    return mDoc.affectsKey(key);\n  },\n  /**\n   * @method Utility.expandObj\n   * @private\n   * @param  {Object} doc\n   * @return {Object}\n   *\n   * Takes a flat object and returns an expanded version of it.\n   */\n  expandObj: function expandObj(doc) {\n    var newDoc = {}, subkeys, subkey, subkeylen, nextPiece, current;\n    _.each(doc, function(val, key) {\n      subkeys = key.split('.');\n      subkeylen = subkeys.length;\n      current = newDoc;\n      for (var i = 0; i < subkeylen; i++) {\n        subkey = subkeys[i];\n        if (typeof current[subkey] !== 'undefined' && !_.isObject(current[subkey])) {\n          break; // already set for some reason; leave it alone\n        }\n        if (i === subkeylen - 1) {\n          // last iteration; time to set the value\n          current[subkey] = val;\n        } else {\n          // see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n          if (isNaN(nextPiece) && !_.isObject(current[subkey])) {\n            current[subkey] = {};\n          } else if (!isNaN(nextPiece) && !_.isArray(current[subkey])) {\n            current[subkey] = [];\n          }\n        }\n        current = current[subkey];\n      }\n    });\n    return newDoc;\n  },\n  /**\n   * @method Utility.compactArrays\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference, compacting any arrays at any level recursively.\n   */\n  compactArrays: function compactArrays(obj) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          obj[key] = _.without(val, void 0, null);\n          _.each(obj[key], function (arrayItem) {\n            compactArrays(arrayItem);\n          });\n        } else if (!(val instanceof Date) && _.isObject(val)) {\n          // recurse into objects\n          compactArrays(val);\n        }\n      });\n    }\n  },\n  /**\n   * @method Utility.bubbleEmpty\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference.\n   */\n  bubbleEmpty: function bubbleEmpty(obj, keepEmptyStrings) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          _.each(val, function (arrayItem) {\n            bubbleEmpty(arrayItem);\n          });\n        } else if (isBasicObject(val)) {\n          var allEmpty = _.all(val, function (prop) {\n            return (prop === void 0 || prop === null || (!keepEmptyStrings && typeof prop === 'string' && prop.length === 0));\n          });\n          if (_.isEmpty(val) || allEmpty) {\n            obj[key] = null;\n          } else {\n            // recurse into objects\n            bubbleEmpty(val);\n          }\n        }\n      });\n    }\n  },\n  /**\n   * @method Utility.isNullUndefinedOrEmptyString\n   * @private\n   * @param  {Any} val\n   * @return {Boolean}\n   *\n   * Returns `true` if the value is null, undefined, or an empty string\n   */\n  isNullUndefinedOrEmptyString: function isNullUndefinedOrEmptyString(val) {\n    return (val === void 0 || val === null || (typeof val === 'string' && val.length === 0));\n  },\n  /**\n   * @method Utility.isValidDateString\n   * @private\n   * @param  {String}  dateString\n   * @return {Boolean}\n   *\n   * Returns `true` if dateString is a \"valid date string\"\n   */\n  isValidDateString: function isValidDateString(dateString) {\n    var m = moment(dateString, 'YYYY-MM-DD', true);\n    return m && m.isValid();\n  },\n  /**\n   * @method Utility.isValidTimeString\n   * @private\n   * @param  {String}  timeString\n   * @return {Boolean}\n   *\n   * Returns `true` if timeString is a \"valid time string\"\n   */\n  isValidTimeString: function isValidTimeString(timeString) {\n    if (typeof timeString !== 'string') {\n      return false;\n    }\n\n    // this reg ex actually allows a few invalid hours/minutes/seconds, but\n    // we can catch that when parsing\n    var regEx = /^[0-2][0-9]:[0-5][0-9](:[0-5][0-9](\\.[0-9]{1,3})?)?$/;\n    return regEx.test(timeString);\n  },\n  /**\n   * @method  Utility.isValidNormalizedForcedUtcGlobalDateAndTimeString\n   * @private\n   * @param  {String} dateString\n   * @return {Boolean}\n   *\n   * Returns true if dateString is a \"valid normalized forced-UTC global date and time string\"\n   */\n  isValidNormalizedForcedUtcGlobalDateAndTimeString: function isValidNormalizedForcedUtcGlobalDateAndTimeString(dateString) {\n    if (typeof dateString !== 'string') {\n      return false;\n    }\n\n    var datePart = dateString.substring(0, 10);\n    var tPart = dateString.substring(10, 11);\n    var timePart = dateString.substring(11, dateString.length - 1);\n    var zPart = dateString.substring(dateString.length - 1);\n    return Utility.isValidDateString(datePart) && tPart === 'T' && Utility.isValidTimeString(timePart) && zPart === 'Z';\n  },\n  /**\n   * @method  Utility.isValidNormalizedLocalDateAndTimeString\n   * @private\n   * @param  {String} dtString\n   * @return {Boolean}\n   *\n   * Returns true if dtString is a \"valid normalized local date and time string\"\n   */\n  isValidNormalizedLocalDateAndTimeString: function isValidNormalizedLocalDateAndTimeString(dtString) {\n    if (typeof dtString !== 'string') {\n      return false;\n    }\n\n    var datePart = dtString.substring(0, 10);\n    var tPart = dtString.substring(10, 11);\n    var timePart = dtString.substring(11, dtString.length);\n    return Utility.isValidDateString(datePart) && tPart === 'T' && Utility.isValidTimeString(timePart);\n  },\n  /**\n   * @method Utility.getComponentContext\n   * @private\n   * @param  {Object} context A context (`this`) object\n   * @param {String} name The name of the helper or component we're calling from.\n   * @return {Object} Normalized context object\n   *\n   * Returns an object with `atts` and `defs` properties, normalized from whatever object is passed in.\n   * This helps deal with the fact that we have to pass the ancestor autoform's context to different\n   * helpers and components in different ways, but in all cases we want to get access to it and throw\n   * an error if we can't find an autoform context.\n   */\n  getComponentContext: function autoFormGetComponentContext(context, name) {\n    var atts, defs = {}, formComponentAttributes, fieldAttributes, fieldAttributesForComponentType, ss;\n\n    atts = _.clone(context || {});\n    ss = AutoForm.getFormSchema();\n\n    defs = Utility.getFieldDefinition(ss, atts.name);\n    if (!defs) return;\n\n    // Look up the tree if we're in a helper, checking to see if any ancestor components\n    // had a <componentType>-attribute specified.\n    formComponentAttributes = AutoForm.findAttributesWithPrefix(name + '-');\n\n    // Get any field-specific attributes defined in the schema.\n    // They can be in autoform.attrName or autoform.componentType.attrName, with\n    // the latter overriding the former.\n    fieldAttributes = _.clone(defs.autoform) || {};\n    fieldAttributesForComponentType = fieldAttributes[name] || {};\n    fieldAttributes = _.omit(fieldAttributes, Utility.componentTypeList);\n    fieldAttributes = _.extend({}, fieldAttributes, fieldAttributesForComponentType);\n\n    // \"autoform\" option in the schema provides default atts\n    atts = _.extend({}, formComponentAttributes, fieldAttributes, atts);\n\n    // eval any attribute that is provided as a function\n    var evaluatedAtts = {};\n    _.each(atts, function (v, k) {\n      if (typeof v === 'function') {\n        evaluatedAtts[k] = v.call({\n          name: atts.name\n        });\n      } else {\n        evaluatedAtts[k] = v;\n      }\n    });\n\n    return {\n      atts: evaluatedAtts,\n      defs: defs\n    };\n  },\n  /**\n   * @method Utility.stringToArray\n   * @private\n   * @param {String|Array} s A variable that might be a string or an array.\n   * @param {String} errorMessage Error message to use if it's not a string or an array.\n   * @return {Array} The array, building it from a comma-delimited string if necessary.\n   */\n  stringToArray: function stringToArray(s, errorMessage) {\n    if (typeof s === 'string') {\n      return s.replace(/ /g, '').split(',');\n    } else if (!_.isArray(s)) {\n      throw new Error(errorMessage);\n    } else {\n      return s;\n    }\n  },\n  /**\n   * @method Utility.addClass\n   * @private\n   * @param {Object} atts An object that might have a \"class\" property\n   * @param {String} klass The class string to add\n   * @return {Object} The object with klass added to the \"class\" property, creating the property if necessary\n   */\n  addClass: function addClass(atts, klass) {\n    if (typeof atts['class'] === 'string') {\n      atts['class'] += ' ' + klass;\n    } else {\n      atts['class'] = klass;\n    }\n    return atts;\n  },\n  /**\n   * @method Utility.getFormTypeDef\n   * @private\n   * @param {String} formType The form type\n   * @return {Object} The definition. Throws an error if type hasn't been defined.\n   */\n  getFormTypeDef: function getFormTypeDef(formType) {\n    var ftd = AutoForm._formTypeDefinitions[formType];\n    if (!ftd) {\n      throw new Error('AutoForm: Form type \"' + formType + '\" has not been defined');\n    }\n    return ftd;\n  },\n  checkTemplate: function checkTemplate(template) {\n    return !!(template &&\n            template.view &&\n            template.view._domrange &&\n            !template.view.isDestroyed);\n  },\n  // This is copied from mongo-object to avoid a direct dep on that package\n  makeKeyGeneric(key) {\n    if (typeof key !== 'string') return null;\n    return key.replace(/\\.[0-9]+(?=\\.|$)/g, '.$');\n  },\n};\n\n// getPrototypeOf polyfill\nif (typeof Object.getPrototypeOf !== 'function') {\n  if (typeof ''.__proto__ === 'object') {\n    Object.getPrototypeOf = function(object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function(object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n *\n * @param {any} obj\n * @returns {Boolean}\n */\nvar isBasicObject = function(obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n"]},"sourceType":"script","hash":"e6db64d555fa9c8cb3fbf2e3d9fdab3131d9dacc"}
